## MiniMax和alpha-beta剪枝

```python
def minimax(board, depth, alpha, beta, maximizing_player, player):
    terminal, score = is_terminal(board, player)
    if depth == 0 or terminal:
        return score if terminal else evaluate(board, player)
  
    possible_moves = get_possible_moves(board)
    if maximizing_player:  # AI（最大化玩家）
        max_eval = -float('inf')
        for move in possible_moves:
            i, j = move
            board[i][j] = player
            eval_score = minimax(board, depth - 1, alpha, beta, False, player)
            board[i][j] = 0  # 回溯
            max_eval = max(max_eval, eval_score)
            alpha = max(alpha, eval_score)
            if beta <= alpha:
                break  # Alpha-Beta剪枝
        return max_eval
    else: 
        min_eval = float('inf')
        for move in possible_moves:
            i, j = move
            board[i][j] = -player
            eval_score = minimax(board, depth - 1, alpha, beta, True, player)
            board[i][j] = 0
            min_eval = min(min_eval, eval_score)
            beta = min(beta, eval_score)
            if beta <= alpha:
                break
        return min_eval
```

**Alpha 和 Beta 的含义回顾**：

- **α (Alpha)**：最大化玩家（AI）的**下界保证**。它表示“AI 已经找到的、至少能达到的最好分数”。初始为 -∞。
- **β (Beta)**：最小化玩家（对手）的**上界保证**。表示“对手 已经找到的、最多能让 AI 得到的分数”。初始为 +∞。
- **剪枝条件**：如果 β ≤ α，当前分支（循环）不可能改善最终结果，直接剪掉（break），节省计算。

假设现在AI先手 `maximizing_player`

进入`if`语句

深度优先递归

搜索到指定深度然后回溯

如果发现 beta `<=` alpha 就剪去（由于认定对手一定会选择最优解）