## å…³äºè¯„åˆ†å‡½æ•°
ä½¿ç”¨minimaxç®—æ³•çš„ä¸€ä¸ªå±€é™æ€§æ˜¯éœ€è¦è·å–å±€é¢çš„ç²¾ç¡®è¯„åˆ†ï¼Œéœ€è¦è®¾è®¡è€…æ‹¥æœ‰ä¸€å®šçš„äº”å­æ£‹çŸ¥è¯†ã€‚åŒæ—¶è¯„åˆ†å‡½æ•°çš„æƒé‡å¤§éƒ½é ç»éªŒæ¥è®¾ç½®ï¼Œè¿™æ˜¾ç„¶ä¸è®¾è®¡AIçš„åˆè¡·ä¸ä¸€è‡´ï¼Œæ‰€ä»¥è¯´è¿˜æ˜¯åº”è¯¥èµ°AlphaZeroçš„è·¯çº¿ğŸ¤”

AIçš„äº‹è¿˜æ˜¯å¾—AIæ¥

## åŸå§‹
```python
def evaluate(board, player):
    score = 0
    opponent = BLACK_STONE if player == WHITE_STONE else WHITE_STONE

    directions = [
        (1,0),
        (0,1),
        (1,1),
        (1,-1)
    ]

    def get_score(current_player):
        s = 0
        for i in range(BOARD_SIZE):
            for j in range(BOARD_SIZE):
                if board[i][j] != current_player:
                    continue
                for d_x, d_y in directions:
                    prev_r = i - d_x
                    prev_c = j - d_y
                    if 0 <= prev_r < BOARD_SIZE and 0 <= prev_c < BOARD_SIZE and board[prev_r][prev_c] == current_player:
                        continue

                    count = 1
                    x = i + d_x
                    y = j + d_y
                    while 0 <= x < BOARD_SIZE and 0 <= y < BOARD_SIZE and board[x][y] == current_player:
                        count += 1
                        x += d_x
                        y += d_y

                    if count >= 5:
                        s += 1919810
                    elif count == 4:
                        s += 1000
                    elif count == 3:
                        s += 100
                    elif count == 2:
                        s += 10
        return s

    score += get_score(player)
    score -= get_score(opponent)

    return score
```

## ä¼˜åŒ–
```python
    # æƒé‡
    W_FIVE = 100000
    W_FOUR_OPEN = 10000
    W_FOUR_HALF = 2500
    W_THREE_OPEN = 1500
    W_THREE_HALF = 200
    W_TWO_OPEN = 100
    W_GAPPED_BONUS = 400  # é—´éš”ä¸€æ ¼æ¥æˆçš„æ‰©å±•ä»·å€¼
    OPPONENT_WEIGHT = 1.2  # å¯¹æ‰‹åˆ†æ”¾å¤§ï¼ˆé¼“åŠ±é˜²å®ˆï¼‰
    IMMEDIATE_THREAT_PENALTY = 1000000  # è‹¥å¯¹æ‰‹æœ‰ç«‹å³å¿…èƒœç‚¹ï¼Œå¼ºåˆ¶è¿”å›æå°å€¼
```


```python
        cnt = 0
        x = i
        y = j
        while in_bounds(x,y) and board[x][y] == cur:
            cnt += 1
            x += dx
            y += dy
        right_x, right_y = x, y
```

- ä» `(i,j)` å¼€å§‹ï¼Œæ²¿ `(dx,dy)` è¿ç»­è®¡æ•°ç›¸åŒé¢œè‰² `cur` çš„æ£‹å­æ•° `cnt`ï¼Œç›´åˆ°é‡åˆ°è¾¹ç•Œæˆ–é `cur` çš„æ ¼å­ã€‚
- å¾ªç¯ç»“æŸåï¼Œ `(right_x, right_y)` æ ‡è®°çš„æ˜¯ç¬¬ä¸€ä¸ªä¸å±äº `cur` çš„æ ¼å­ï¼ˆå¯èƒ½è¶Šç•Œã€å¯¹æ–¹æ£‹å­æˆ–ç©ºæ ¼ï¼‰ã€‚

```python
        left_x, left_y = i - dx, j - dy
```

æ£€æŸ¥å·¦ä¾§æ˜¯å¦ä¸ºç©ºæˆ–è¢«å µã€‚

```python
        left_empty = (in_bounds(left_x,left_y) and board[left_x][left_y] == EMPTY)
        left_blocked = (not in_bounds(left_x,left_y)) or (in_bounds(left_x,left_y) and board[left_x,left_y] == opp)
```

- åˆ¤æ–­å·¦ä¾§çŠ¶æ€ï¼š

```python
        right_empty = (in_bounds(right_x,right_y) and board[right_x][right_y] == EMPTY)
        right_blocked = (not in_bounds(right_x,right_y)) or (in_bounds(right_x,right_y) and board[right_x,right_y] == opp)
```

åŒç†ï¼Œå³ä¾§

```python
        open_ends = (1 if left_empty else 0) + (1 if right_empty else 0)
```

ç»Ÿè®¡è¿å­ä¸¤ç«¯ç©ºæ ¼æ•°é‡ï¼ˆ0ã€1 æˆ– 2ï¼‰

```python
        score = 0
        threats = set()
        immediate_win = False
```

### è¿å­é•¿åº¦ä¸å¨èƒ

```python
        if cnt >= 5:
            score += W_FIVE
            immediate_win = True
```

```python
        elif cnt == 4:
            if open_ends == 2:
                score += W_FOUR_OPEN
                if cur == opponent:
                    immediate_win = True
                if left_empty:
                    threats.add((left_x,left_y))
                if right_empty:
                    threats.add((right_x,right_y))
            elif open_ends == 1:
                score += W_FOUR_HALF
                if left_empty:
                    threats.add((left_x,left_y))
                if right_empty:
                    threats.add((right_x,right_y))
                if cur == opponent:
                    immediate_win = True
            else:
                score += W_FOUR_HALF // 4
```

```python
        elif cnt == 3:
            if open_ends == 2:
                score += W_THREE_OPEN
                if left_empty:
                    threats.add((left_x,left_y))
                if right_empty:
                    threats.add((right_x,right_y))
            elif open_ends == 1:
                score += W_THREE_HALF
                if left_empty:
                    threats.add((left_x,left_y))
                if right_empty:
                    threats.add((right_x,right_y))
            else:
                score += 30
```

```python
        elif cnt == 2:
            if open_ends == 2:
                score += W_TWO_OPEN
            elif open_ends == 1:
                score += 8
            else:
                score += 2
        elif cnt == 1:
            if open_ends == 2:
                score += 3
```
### é—´éš”ä¸€æ ¼

```python
        if in_bounds(right_x,right_y) and board[right_x][right_y] == EMPTY:
            after_gap_x = right_x + dx
            after_gap_y = right_y + dy
            if in_bounds(after_gap_x, after_gap_y) and board[after_gap_x][after_gap_y] == cur:
                score += W_GAPPED_BONUS * (cnt)
                threats.add((right_x,right_y))
                if cur == opponent and (cnt + 1) >= 4:
                    immediate_win = True
```

```python
        if in_bounds(left_x,left_y) and board[left_x,left_y] == EMPTY:
            before_gap_x = left_x - dx
            before_gap_y = left_y - dy
            if in_bounds(before_gap_x, before_gap_y) and board[before_gap_x,before_gap_y] == cur:
                score += W_GAPPED_BONUS * (cnt)
                threats.add((left_x,left_y))
                if cur == opponent and (cnt + 1) >= 4:
                    immediate_win = True
```

### éå†æ•´ç›˜

```python
    def get_aggregate(cur):
        total = 0
        threat_positions = set()
        has_immediate = False
        for i in range(BOARD_SIZE):
            for j in range(BOARD_SIZE):
                if board[i][j] != cur:
                    continue
                for dx,dy in directions:
                    prev_x, prev_y = i - dx, j - dy
                    if in_bounds(prev_x, prev_y) and board[prev_x][prev_y] == cur:
                        continue
                    add, threats, immediate = analyze_from(i,j,dx,dy,cur)
                    total += add
                    threat_positions |= threats
                    if immediate:
                        has_immediate = True
        return total, threat_positions, has_immediate
```

```python
    if opp_immediate:
        return -IMMEDIATE_THREAT_PENALTY
```

```python
    threat_penalty = len(opp_threats) * 2000
    score = (my_score - OPPONENT_WEIGHT * opp_score) - threat_penalty
```
